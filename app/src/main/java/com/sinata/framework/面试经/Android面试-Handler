
1.1Handler的实现原理

链接：https://www.zhihu.com/question/19703357/answer/119024815

1、我们先说下什么是Android消息处理机制？消息处理机制本质：一个线程开启循环模式持续监听并依次处理其他线程给它发的消息。简单的说：一个线程开启一个无限循环模式，不断遍历自己的消息列表，如果有消息就挨个拿出来做处理，如果列表没消息，自己就堵塞（相当于wait，让出cpu资源给其他线程），其他线程如果想让该线程做什么事，就往该线程的消息队列插入消息，该线程会不断从队列里拿出消息做处理。2、Android消息处理机制的工作原理？打个比方：公司类比AppPM 的主要工作是设计产品，写需求文档，改需求,中途改需求，提测前改需求...UI 主要工作是UI设计，交互等。RD 工作我就不说了CEO 不解释。公司开创之后（App启动），那么CEO开始干活了（主线程【UI线程】启动），这时候CEO开启了无限循环工作狂模式，自己的公司没办法啊（相当于UI主线程转成Looper线程【源码里面有】）CEO招了一名RD（new Handler 实例）并把告诉PM和UI,如果你们有什么任务和需求就让RD（Handler实例）转告给我（CEO）。RD会把PM和UI的需求（Message）一条条记到CEO的备忘录里（MessageQueue）。CEO 无限循环的工作就是不断查看备忘录，看有什么任务要做，有任务就从备忘录一条一条拿出任务来，然后交给这一名RD（Handler 实例）去处理（毕竟CEO 不会写代码 囧...）。当然如果备忘录都做完了，这时候CEO就会去睡觉（线程堵塞【简单理解成线程wait】，让出CPU资源，让其他线程去执行）。但是这个备忘录有个特殊的功能就是没有任务的时候突然插入第一条任务（从无到有）就会有闹钟功能叫醒CEO起床继续处理备忘录。 整个消息处理机制的工作原理基本就是这样的。后面会有源码分析，你再来结合这个场景，会更好理解一些。这里先给一张Android消息处理机制流程图和具体执行动画，如果看不懂没事，接着往下看（后面会结合Android UI主线程来讲解），然后结合着图和动画一块看更能理解整个机制的实现原理。&lt;img src="https://pica.zhimg.com/50/e03907fead023dc753bf8777548d3bac_720w.jpg?source=1940ef5c" data-rawwidth="1008" data-rawheight="720" class="origin_image zh-lightbox-thumb" width="1008" data-original="https://pic3.zhimg.com/e03907fead023dc753bf8777548d3bac_r.jpg?source=1940ef5c"/&gt;3、Looper、Handler、MessageQueue,Message作用和存在的意义？Looper 我们知道一个线程是一段可执行的代码，当可执行代码执行完成后，线程生命周期便会终止，线程就会退出，那么做为App的主线程，如果代码段执行完了会怎样？，那么就会出现App启动后执行一段代码后就自动退出了，这是很不合理的。所以为了防止代码段被执行完，只能在代码中插入一个死循环，那么代码就不会被执行完，然后自动退出，怎么在在代码中插入一个死循环呢？那么Looper出现了，在主线程中调用Looper.prepare()...Looper.loop()就会变当前线程变成Looper线程（可以先简单理解：无限循环不退出的线程），Looper.loop()方法里面有一段死循环的代码，所以主线程会进入while(true){...}的代码段跳不出来，但是主线程也不能什么都不做吧？其实所有做的事情都在while(true){...}里面做了，主线程会在死循环中不断等其他线程给它发消息（消息包括：Activity启动，生命周期，更新UI，控件事件等），一有消息就根据消息做相应的处理，Looper的另外一部分工作就是在循环代码中会不断从消息队列挨个拿出消息给主线程处理。MessageQueue MessageQueue 存在的原因很简单，就是同一线程在同一时间只能处理一个消息，同一线程代码执行是不具有并发性，所以需要队列来保存消息和安排每个消息的处理顺序。多个其他线程往UI线程发送消息，UI线程必须把这些消息保持到一个列表（它同一时间不能处理那么多任务),然后挨个拿出来处理，这种设计很简单，我们平时写代码其实也经常这么做。每一个Looper线程都会维护这样一个队列，而且仅此一个，这个队列的消息只能由该线程处理。Handler 简单说Handler用于同一个进程的线程间通信。Looper让主线程无限循环地从自己的MessageQueue拿出消息处理，既然这样我们就知道处理消息肯定是在主线程中处理的，那么怎样在其他的线程往主线程的队列里放入消息呢？其实很简单，我们知道在同一进程中线程和线程之间资源是共享的，也就是对于任何变量在任何线程都是可以访问和修改的，只要考虑并发性做好同步就行了，那么只要拿到MessageQueue 的实例，就可以往主线程的MessageQueue放入消息，主线程在轮询的时候就会在主线程处理这个消息。那么怎么拿到主线程 MessageQueue的实例，是可以拿到的(在主线程下mLooper = Looper.myLooper();mQueue = mLooper.mQueue;),但是Google 为了统一添加消息和消息的回调处理，又专门构建了Handler类，你只要在主线程构建Handler类，那么这个Handler实例就获取主线程MessageQueue实例的引用（获取方式mLooper = Looper.myLooper();mQueue = mLooper.mQueue;），Handler 在sendMessage的时候就通过这个引用往消息队列里插入新消息。Handler 的另外一个作用，就是能统一处理消息的回调。这样一个Handler发出消息又确保消息处理也是自己来做，这样的设计非常的赞。具体做法就是在队列里面的Message持有Handler的引用（哪个handler 把它放到队列里，message就持有了这个handler的引用），然后等到主线程轮询到这个message的时候，就来回调我们经常重写的Handler的handleMessage(Message msg)方法。Message Message 很简单了，你想让主线程做什么事，总要告诉它吧，总要传递点数据给它吧，Message就是这个载体。-------------------------------以上是我最近刚写一篇 Android 消息处理机制（Looper、Handler、MessageQueue,Message）的文章里面的部分内容摘要，本来还有个消息发送和处理的动画（不过知乎放不了动画），可以到我的博客看一下，对于Handler 相关的机制写得比较详细，希望可以帮到你！编辑于 2016-08-26 15:09​赞同 47​​3 条评论​分享​收藏​喜欢收起​Binguner5 人赞同了该回答# 1. 什么是消息机制说到消息机制，作为一名 Android 开发者一定先想到的是 Handler。Handler 就是 Android 消息机制的上层接口，我们可用通过 Handler 轻松的在不同的线程中切换任务，但 Handler 的实现还有两个很重要的概念 MessageQueue 和 Looper。MessageQueue 的翻译是消息队列，它的内部采用了单链表的结构存储 Handler 对象发送的消息。Looper 的作用是不断地查询 MessageQueue 中是否有消息，如果 Looper 发现 MessageQueue 中存入了新的消息，它就会去处理这条消息，如果没有新消息，Looper 就会以无限循环的方式去查询 MessageQueue 中是否有新消息。# 2. 为什么要有 Handler## 2.1）官方文档中 Handler 的主要作用（1）安排将来某个时间点执行的 Message 和 Runnables；（2）在不同于当前的线程上执行的操作；## 2.2）Handler 被用来做的最多的一件事就是更新主线程的 UI。在 Android 开发中，默认子线程是不可以更新 UI 的，这一点可以从 View 的最高层级 ViewRootImpl 类中找到答案void checkThread() {
    if (mThread != Thread.currentThread()) {
        throw new CalledFromWrongThreadException("Only the original thread that created a view hierarchy can touch its views.");
    }
}
ViewRootImpl 类中的 checkThread 方法会在更新 UI 前被执行，如果当前线程不是主线程，就会抛出 Only the original thread that created a view hierarchy can touch its views. 的异常## 2.3）那么 Android 为什么要设计为只能在主线程中更新 UI 呢？Android 在子线程中更新 UI 是不安全的，如果多个子线程同时修改一个控件的数据，后果是不可控的如果给 UI 更新机制加锁，会降低 UI 的访问效率，并且可能阻塞某些线程的执行# 3. Handler 的用法## 3.1）在主线程中创建 Handler通常，我们在主线程中创建 Handler 的写法如下：private Handler handler = new Handler(){
    @Override
    public void handleMessage(Message msg) {
        super.handleMessage(msg);
    }
};
但这样写，系统会这样提示：This Handler class should be static or leaks might occur (anonymous android.os.Handler)
这个Handler类应该是静态的，否则可能会发生泄漏
出现这个警告但原因是，Handler 在 Activity 中作为一个匿名内部类来定义，它的内部持有来 Activity 的实例。当 Activity 被用户关闭时，因为 Handler 持有了 Activity 的引用，就造成了 Activity 无法被回收，从而导致了内存泄漏。因此，在这里推荐一种更加安全的写法：private static class MyHandler extends Handler{
    private WeakReference<Activity> weakReference;
    public MyHandler(Activity activity){
        weakReference = new WeakReference<>(activity);
    }

    @Override
    public void handleMessage(Message msg) {
        super.handleMessage(msg);
        switch (msg.what){
                case 0:
                  Toast.makeText(weakReference.get(),Thread.currentThread().getName(),Toast.LENGTH_SHORT).show();
                  break;
            }
    }
}

private MyHandler handler = new MyHandler(this);
通过静态内部类的方式实现一个 Handler，此时内部类并不持有外部类对象的应用，需要在内部类的构造方法内增加一个外部类（Activity）的弱应用。这样，即使 Activity 被关闭，Activity 也能顺利被回收。onCreate() 中的代码如下：btn_0 = findViewById(R.id.btn_0);
btn_0.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        new Thread(){
            @Override
            public void run() {
                super.run();
                Message message = Message.obtain();
                message.what = 0;
                handler.sendMessage(message);
            }
        }.start();
    }
});
这时候点击按钮的运行效果如下：&lt;img src="https://pic3.zhimg.com/50/v2-813f612d5fa75302d98400e28685e0bc_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="618" data-rawheight="952" data-default-watermark-src="https://pic3.zhimg.com/50/v2-bec0db34032b8a6909b26aae9b3e501d_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="618" data-original="https://pic1.zhimg.com/v2-813f612d5fa75302d98400e28685e0bc_r.jpg?source=1940ef5c"/&gt;## 3.2）在子线程中创建 Handler在官方文档中 Handler 的主要作用是在不同于当前线程的线程中执行操作，那么如何用 Handler 解决两个子线程之间的通信呢？请看代码：btn_1 = findViewById(R.id.btn_1);
btn_1.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        new Thread(){
            @Override
            public void run() {
                super.run();
                Looper.prepare();
                handler = new MyHandler(MainActivity.this);
                try {
                    sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                Looper.loop();
            }
        }.start();
        new Thread(){
            @Override
            public void run() {
                super.run();
                Message message = Message.obtain();
                message.what = 0;
                handler.sendMessage(message);
            }
        }.start();
     }
});
此时点击按钮：&lt;img src="https://pic3.zhimg.com/50/v2-4c85f7dfb71994ab125cdf88991b30d2_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="618" data-rawheight="952" data-default-watermark-src="https://pic1.zhimg.com/50/v2-6400f0669c27b3f2e249ba4a09fc091b_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="618" data-original="https://pica.zhimg.com/v2-4c85f7dfb71994ab125cdf88991b30d2_r.jpg?source=1940ef5c"/&gt;可见当前的处理线程已经变成了子线程。# 4. Handler 工作原理如果细心的观察代码，可以看到在子线程中创建 Handler 的时候调用了 Looper.prepare() 和 Looper.loop() 两个方法。这两句代码有什么用呢？我们暂时可以把 Looper 理解为消息的管理者，它负责从 MessageQueue 中提取出消息，传递给 Handler 进行处理，每一个 Handler 都必须要有一个 Looper，在 Handler 创建的时候，它会自动使用当前线程的 Looper，而 Looper.prepare() 的作用就是为当前线程准备一个 Looper，Looper.loop() 的作用是开始查找当前 MessageQueue 中是否有了新的消息。这就是 Handler 工作的第一步 ：## 4.1）采用当前线程的 Looper 创建 Handler因为这里主要讲 Handler 的工作流程，创建 Looper 的具体过程放到文章的下面讲解。我们只要知道 Looper.prepare() 为当前的线程创建了一个 Looper 对象即可。但是，在主线程中创建 Handler 的时候，我们并没有看到 Looper.prepare() 的执行，这是因为在 UI 线程，即 ActivityThread 的创建过程中，Looper 已经被创建好了。我们可以在 ActivityThread 的 main() 方法中看到这样一句代码：Looper.prepareMainLooper();
这个方法内部也调用了 Looper.prepare() 为 UI 线程创建了一个 Looper。## 4.2）通过 Handler 的 `sendMessageAtTime()` 方法发送 Message为什么是 sendMessageAtTime？不是还有 sendMessage()，sendEmptyMessage()，sendEmptyMessageDelayed()，sendEmptyMessageAtTime()，sendMessageDelayed() 这么多方法吗？通过阅读这些方法的源码可以发现，这些方法最终调用的都是 sendMessageAtTime()。其次还有 post()，postAtTime()，postDelayed() 方法最终调用的也都是 sendMessageAtTime() 方法，只是多了一步调用 getPostMessage(Runnable r, Object token) 将 Runnable 封装为一个 Message 对象的 callback 里。public final boolean post(Runnable r){
   return  sendMessageDelayed(getPostMessage(r), 0);
}

private static Message getPostMessage(Runnable r) {
    Message m = Message.obtain();
    m.callback = r;
    return m;
}
那么 sendMessageAtTime() 里的具体操作是什么呢？我们去源码里一探究竟public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
    // 先获取当前 Handler 中的 MessageQueue，mQueue 在 Looper 的构造方法中进行初始化。
    MessageQueue queue = mQueue;
    if (queue == null) {
        RuntimeException e = new RuntimeException(
                this + " sendMessageAtTime() called with no mQueue");
        Log.w("Looper", e.getMessage(), e);
        return false;
    }
    // queue 不为空，则执行 Handler.java 里的另一个 enqueueMessage() 方法
    return enqueueMessage(queue, msg, uptimeMillis);
}


private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
    // 指定 msg 的 Target 对象为当前的 Handler
    msg.target = this;
    if (mAsynchronous) {
       msg.setAsynchronous(true);
    }
    return queue.enqueueMessage(msg, uptimeMillis);
}
Handler 中的 enqueueMessage() ，最终会调用 MessageQueue.java 中的 enqueueMessage() 方法。之后，Message 对象最终传递到 MessageQueue 即消息队列里中，在消息队列里的具体处理逻辑在文章的 MessageQueue 工作原理 部分会具体解释。## 4.3）Looper 处理消息后调用 Handler 的 dispatchMessage() 方法在第二步将消息插入消息队列后，Looper 就开始遍历消息队列，找到新的消息，再通知 Handler 去执行这条消息，调用的就是 Handler 的 dispatchMessage() 方法。public void dispatchMessage(Message msg) {
   // msg 的 callback 对象就是一个 Runnable
   if (msg.callback != null) {
        handleCallback(msg);
    } else {
        // 检查 mCallback 是否为空，不为空就执行它内部定义的 handleMessage() 方法
        if (mCallback != null) {
            if (mCallback.handleMessage(msg)) {
                return;
            }
        }
        // 如果 mCallback 为空，就执行在实例化 Handler 过程中我们自己定义的 handleMessage() 方法中的内容
        handleMessage(msg);
    }
}
dispatchMessage() 方法首先会检查 Message 的 Callback 对象是否为空，callback 就是通过 post() 方法传递的 Runnable 对象，如果 callback 不为空，就去执行 handleCallback() 方法。handleCallback() 方法的实现也很简单，它在内部执行了 Runnable 的 run() 方法private static void handleCallback(Message message) {
    message.callback.run();
}
如果 callback 对象为空，就检查 mCallback 是否为空，不为空就执行它的定义的  handleMessage() 方法，若没有 mCallback，最终将直接执行我们在继承 Handler 时自己定义的 handleMessage() 方法中的代码。Callback 是 Handler 中定义的的一个接口，它的代码如下：/**
 * Callback interface you can use when instantiating a Handler to avoid
 * having to implement your own subclass of Handler.
 */
public interface Callback {
    /**
     * @param msg A {@link android.os.Message Message} object
     * @return True if no further handling is desired
     */
    public boolean handleMessage(Message msg);
}
如果使用 Callback 接口的话，我们可以直接实例化一个 Handler 而不用去实现一个 Handler 的子类，private Handler mHandler = new Handler(new Handler.Callback() {
    @Override
    public boolean handleMessage(Message msg) {
        return false;
    }
});
# 5. MessageQueue 工作原理我们从上一部分的 MessageQueue.java 中的 enqueueMessage() 方法开始入手。## 5.1）enqueueMessage()代码量有点多，要耐心看哦！boolean enqueueMessage(Message msg, long when) {
    // 检查当前 msg 的 target 是否为空
    if (msg.target == null) {
        throw new IllegalArgumentException("Message must have a target.");
    }
    // msg 如果正在被执行，就抛出异常
    if (msg.isInUse()) {
        throw new IllegalStateException(msg + " This message is already in use.");
    }

    synchronized (this) {
        // 在 quit() 方法中，mQuitting 会被设置为 true
        if (mQuitting) {
            IllegalStateException e = new IllegalStateException(
                    msg.target + " sending message to a Handler on a dead thread");
            Log.w(TAG, e.getMessage(), e);
            msg.recycle();
            return false;
        }

        // 标记当前的 msg 正在执行
        msg.markInUse();
        // 设置 msg 的 when 为传进来的 when 参数，when 是 Message 想要被执行的时间
        msg.when = when;
        // 得到当前消息队列的头部消息
        Message p = mMessages;
        boolean needWake;
        // 当前消息队列为空，新消息的触发时间为 0，或者新消息的触发时间早于消息中第一条消息的触发时间
        // 则将新消息插入到队列的头部，作为当前消息队列的第一条消息
        if (p == null || when == 0 || when < p.when) {
            // New head, wake up the event queue if blocked.
            // 将当前消息的下一条消息指向头部消息
            msg.next = p;
            // 头部消息修改为当前消息
            mMessages = msg;
            // 当阻塞时，需要唤醒
            needWake = mBlocked;
        } else {
            // 将新消息插入到当前消息队列当中，（不是头部）
            // 通常我们不必唤醒事件队列，
            // 除非队列头部有消息障碍，并且消息是队列中最早的异步消息。
            needWake = mBlocked && p.target == null && msg.isAsynchronous();
            Message prev;
            // 开始循环便利消息队列，比较新消息和队列中消息的 when（触发事件）的值，将新消息插入到适当位置
            for (;;) {
                // 循环第一次遍历时，将当前队列中的头部消息赋值给 prev
                prev = p;
                // p 指向队列中的第二个消息
                p = p.next;
                // 如果下一个消息为空，或者新消息的触发时间早于下一个消息，找到了要插入的位置，退出循环
                if (p == null || when < p.when) {
                    break;
                }
                // needWake 为 true，并且 下一条消息是异步的，则不需要唤醒。
                if (needWake && p.isAsynchronous()) {
                    needWake = false;
                }
            }
            // 将新消息插入到 p 之前，头消息之后。
            msg.next = p; // invariant: p == prev.next
            prev.next = msg;
        }

        // 如果需要唤醒，调用 nativeWake 方法去唤醒
        if (needWake) {
            nativeWake(mPtr);
        }
    }
    return true;
}
执行完 enqueueMassage 方法，我们新发送的 Message 就成功的插入了消息队列当中。但是除了插入新消息，我们还需要从消息队列中读取消息，这又要怎么做呢？## 5.2）next()Message next() {
    // 如果消息循环已退出，并且被丢弃，则返回空。
    // 这个将在应用重启一个 looper 时发生
    final long ptr = mPtr;
    if (ptr == 0) {
        return null;
    }

    // 记录空闲时处理的 IdlerHandler 数量，只在第一次迭代时为 -1
    // IdleHandler 只在队列为空 或者 是头部消息时执行
    int pendingIdleHandlerCount = -1;
    //  native 层使用的变量，设置的阻塞超时时长，0 为不阻塞，-1 为阻塞
    int nextPollTimeoutMillis = 0;
    for (;;) {
        if (nextPollTimeoutMillis != 0) {
            Binder.flushPendingCommands();
        }

        nativePollOnce(ptr, nextPollTimeoutMillis);

        // 尝试检索下一条消息。 如果找到则返回。
        synchronized (this) {
            // 获取系统从开机到现在到时间
            final long now = SystemClock.uptimeMillis();
            Message prevMsg = null;
            // 将队列中到头部消息赋值给 msg
            Message msg = mMessages;
            if (msg != null && msg.target == null) {
                // msg 不为空，但是这个 msg 没有 handler，则这个 msg 为栅栏
                // 开始遍历，指到获取第一个异步消息
                do {
                    prevMsg = msg;
                    msg = msg.next;
                } while (msg != null && !msg.isAsynchronous());
            }
            if (msg != null) {
                // 如果当前时间不到 msg 的触发时间，则计算时间差，设置阻塞超时时长
                if (now < msg.when) {
                    // Next message is not ready.  Set a timeout to wake up when it is ready.
                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                } else {
                    // 当前时间到了 msg 的触发时间，则获取消息并返回
                    mBlocked = false;
                    // 如果当前的 msg 不是头部消息，则上一条消息的 next 指向 msg 的 next
                    if (prevMsg != null) {
                        prevMsg.next = msg.next;
                    } else {
                        // 当前 msg 为头部消息，则将下一个 msg 设置为头部消息
                        mMessages = msg.next;
                    }
                    // msg 的下一个 Message 对象置空，表示从消息队列中取出来了这条 msg
                    msg.next = null;
                    if (DEBUG) Log.v(TAG, "Returning message: " + msg);
                    // 标记 msg 正在使用
                    msg.markInUse();
                    return msg;
                }
            } else {
                // 如果没有消息，则设置阻塞时长为 -1，直到被唤醒
                nextPollTimeoutMillis = -1;
            }

            // 所有的消息都被处理后，判断是否退出，并返回 null。
            if (mQuitting) {
                dispose();
                return null;
            }

            // If first time idle, then get the number of idlers to run.
            // Idle handles only run if the queue is empty or if the first message
            // in the queue (possibly a barrier) is due to be handled in the future.
            // 第一次循环时，消息队列为空，或 当前时间未到消息的触发时间，获取 IdleHandler 的数量
            if (pendingIdleHandlerCount < 0
                    && (mMessages == null || now < mMessages.when)) {
                pendingIdleHandlerCount = mIdleHandlers.size();
            }

            // pendingIdleHandlerCount 的数量为 0 时，线程会继续堵塞
            if (pendingIdleHandlerCount <= 0) {
                // No idle handlers to run.  Loop and wait some more.
                mBlocked = true;
                continue;
            }

            // 判断当前空闲时处理任务的handler是否是为空，如果为空，就实例化出新的对象
            if (mPendingIdleHandlers == null) {
                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
            }
            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
        }

        // 运行 IdleHandler，只有第一次循环时才会运行
        for (int i = 0; i < pendingIdleHandlerCount; i++) {
            final IdleHandler idler = mPendingIdleHandlers[i];
            // 释放 IdleHandler 的引用
            mPendingIdleHandlers[i] = null;

            boolean keep = false;
            try {
                // 执行 IdleHandler 的方法
                keep = idler.queueIdle();
            } catch (Throwable t) {
                Log.wtf(TAG, "IdleHandler threw exception", t);
            }

            if (!keep) {
                synchronized (this) {
                    mIdleHandlers.remove(idler);
                }
            }
        }

        // 重置 IdleHandler 的数量为 0，确保不会重复运行它们
        pendingIdleHandlerCount = 0;

        // 在执行 IdleHandler 时，一个新的消息可能插入或消息队列中的消息到了触发时间
        // 所以将 nextPollTimeoutMillis 设为 0，表示不需要阻塞，重新检查消息队列。
        nextPollTimeoutMillis = 0;
    }
}
至此，MessageQueue 的两个最重要的方法已经分析完了，下面来看 Looper 如何循环地从消息队列中取出消息。# 6. Looper 工作原理在讲 Looper 之前，需要先理解 ThreadLocal 的工作原理## 6.1）ThreadLocal 的工作原理ThreadLocal 是一个线程内存储数据的类，当不同的线程去访问同一个 ThreadLocal 对象时，获得的值都是不一样的，下面用一段代码来证明private ThreadLocal<String> mThreadLocal = new ThreadLocal<>();

btn_1 = findViewById(R.id.btn_1);
btn_1.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        new Thread(){
            @Override
            public void run() {
                super.run();
                mThreadLocal.set("Thread_A");
                Log.d("ThreadLocalValue",mThreadLocal.get());
            }
        }.start();
        new Thread(){
            @Override
            public void run() {
                super.run();
                mThreadLocal.set("Thread_B");
                Log.d("ThreadLocalValue",mThreadLocal.get());
            }
        }.start();
    }
);
我在两个线程中分别存入在 mThreadLocal 中存入了不同的值，然后在控制台输出它们的内容&lt;img src="https://pic3.zhimg.com/50/v2-3c973bc30cec1aa474f8f7cb5aef7d02_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="635" data-rawheight="94" class="origin_image zh-lightbox-thumb" width="635" data-original="https://pica.zhimg.com/v2-3c973bc30cec1aa474f8f7cb5aef7d02_r.jpg?source=1940ef5c"/&gt;可见不同线程访问同一个 ThreadLocal 对象得到的值也是不一样的。ThreadLocal 实现这种特性的原因也很简单，下面来看它内部的 set 方法：public void set(T value) {
    // 获取当前线程 t
    Thread t = Thread.currentThread();
    // 根据当前线程 t，获取当前线程的 ThreadLocalMap 对象
    ThreadLocalMap map = getMap(t);
    if (map != null)
        // map 不为空，调用 ThreadLocalMap 的 set() 方法。
        map.set(this, value);
    else
        // map 为空，则为当前线程创建一个新的 ThreadLocalMap 对象
        createMap(t, value);
}
在 set 方法中，先获取当前线程，然后获取当前线程的 ThreadLocalMap 对象。getMap() 的 和 createMap() 的实现如下：ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}

void createMap(Thread t, T firstValue) {
    t.threadLocals = new ThreadLocalMap(this, firstValue);
}
那么 ThreadLocalMap 又是什么呢，这里是它的一部分源码：static class ThreadLocalMap {
    static class Entry extends WeakReference<ThreadLocal<?>> {
        /** The value associated with this ThreadLocal. */
        Object value;

        Entry(ThreadLocal<?> k, Object v) {
            super(k);
            value = v;
        }
    }

    // 初始的 table 容量
    private static final int INITIAL_CAPACITY = 16;

    // Entry 数组用于存储数据
    private Entry[] table;

    // table 的大小
    private int size = 0;

    // 负载因子，用于扩容
    private int threshold; // Default to 0

    // 设置负载因子为当然容量大小的 2 / 3
    private void setThreshold(int len) {
        threshold = len * 2 / 3;
    }

    // 初始化 Entry 数组
    ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {
        table = new Entry[INITIAL_CAPACITY];
        int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);
        table[i] = new Entry(firstKey, firstValue);
        size = 1;
        setThreshold(INITIAL_CAPACITY);
    }
}
可以将 ThreadLocalMap 当作一个哈希表，它的内部用 Entry 存储相应的数据。在 Thread 的属性中有 ThreadLocal.ThreadLocalMap threadLocals = null;，所以每一个线程内部，都持有一个 ThreadLocalMap 对象，系统才可以通过 getMap() 方法获取当前线程的 ThreadLocalMap 对象。在 ThreadLocal 中调用 set 方法，实际上会调用 ThreadLocalMap 中的 set 方法，源码如下：// ThreadLocalMap 的 set 方法
private void set(ThreadLocal<?> key, Object value) {

    // We don't use a fast path as with get() because it is at
    // least as common to use set() to create new entries as
    // it is to replace existing ones, in which case, a fast
    // path would fail more often than not.

    // 首先获取当前 ThreadLocal 对象的 table 属性，table 一个 Entry 的数组
    // Entry 相当于一个 HashMap，存储了当前 ThreadLocal 对象和 Object 类型的 value 对象
    Entry[] tab = table;
    int len = tab.length;
    // 计算出存储的位置
    int i = key.threadLocalHashCode & (len-1);

    // 遍历 tab
    for (Entry e = tab[i];
        e != null;
        e = tab[i = nextIndex(i, len)]) {
        ThreadLocal<?> k = e.get();
        // 如果 tab 中已经存在了相同的 key 值，就覆盖它原有的 value
        if (k == key) {
            e.value = value;
            return;
        }
        // 如果 当前 entrt 的 key 为 null，调用 replaceStaleEntry 方法清楚所有 key 为 null 的数据
        if (k == null) {
            replaceStaleEntry(key, value, i);
            return;
        }
    }
        // 都不满足，就新建一个 Entry 对象
    tab[i] = new Entry(key, value);
    int sz = ++size;
    // ThreadLocalMap 的容量到达阀值后扩容
    if (!cleanSomeSlots(i, sz) && sz >= threshold)
        rehash();
}
ThreadLocal 中的 get() 方法和 set() 方法一样，都是对 Thread 中对 ThreadLocalMap 进行操作public T get() {
    // 获取当前线程
    Thread t = Thread.currentThread();
    // 获取当前线程的 ThreadLocalMap 对象
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        // 获取 ThreadLocalMap 中对应当前线程的 Entry 对象
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings("unchecked")
            // 将 Entry 对象中的 value 取出来
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}

private Entry getEntry(ThreadLocal<?> key) {
    int i = key.threadLocalHashCode & (table.length - 1);
    Entry e = table[i];
    if (e != null && e.get() == key)
        return e;
    else
        return getEntryAfterMiss(key, i, e);
}
## 6.2）Looper 中的 prepare() 方法那么 ThreadLocal 和 Looper 有什么关系呢？我们知道每一个线程都有自己的 Looper，Looper 的作用域就是当前的线程，Android 系统中便通过 ThreadLocal 对象来存储不同线程中的 Looper。Looper 中 prepare() 方法为当前线程创建一个 Looper 对象，我们看一下它的实现：public static void prepare() {
    prepare(true);
}

private static void prepare(boolean quitAllowed) {
    if (sThreadLocal.get() != null) {
        throw new RuntimeException("Only one Looper may be created per thread");
    }
    // 将 Looper 对象保存到当前线程的 ThreadLocalMap 当中
    sThreadLocal.set(new Looper(quitAllowed));
}
这里再看一下 Looper 的构造方法private Looper(boolean quitAllowed) {
    mQueue = new MessageQueue(quitAllowed);
    mThread = Thread.currentThread();
}
可以看到在一个 Looper 中创建了一个 MessageQueue，这里我们就可以搞清楚 Handler、Looper 和 MessageQueue 的对应关系了：每个线程都有一个 Looper 对象，在 Looper 对象的初始化过程中，会为当前线程创建一个 MessageQueue，而一个线程中可以有多个 Handler。## 6.3）Looper 中的 loop() 方法：prepare() 调用后，就是调用 loop() 方法：/**
  * Run the message queue in this thread. Be sure to call
  * {@link #quit()} to end the loop.
  */
public static void loop() {
    // 通过 Thread Local 获取当前线程的 Looper
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
    }
    // 获取当前 Looper 对象的 MessageQueue
    final MessageQueue queue = me.mQueue;

    // 清空远程调用端进程的身份，确保此线程的身份是本地进程的身份，并跟踪该身份令牌
    // 这里主要用于保证消息处理是发生在当前 Looper 所在的线程
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();

    for (;;) {
        // 取出来下一条消息
        Message msg = queue.next(); // might block
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }

        // 用 logging 打印日志，默认为 null，可通过 setMessageLogging() 方法来指定
        final Printer logging = me.mLogging;
        if (logging != null) {
            logging.println(">>>>> Dispatching to " + msg.target + " " +
                    msg.callback + ": " + msg.what);
        }

        // 开始跟踪，并写入跟踪消息，用于 debug 功能
        final long traceTag = me.mTraceTag;
        if (traceTag != 0 && Trace.isTagEnabled(traceTag)) {
            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));
        }
        ...
        ...
        try {
            // // 通过 Handler 分发消息
            msg.target.dispatchMessage(msg);
            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;
        } finally {
            if (traceTag != 0) {
                // 停止跟踪
                Trace.traceEnd(traceTag);
            }
        }

        if (logSlowDispatch) {
            showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, "dispatch", msg);
        }

        if (logging != null) {
            logging.println("<<<<< Finished to " + msg.target + " " + msg.callback);
        }

        //  确保在分发消息的过程中线程的身份没有改变
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, "Thread identity changed from 0x"
                    + Long.toHexString(ident) + " to 0x"
                    + Long.toHexString(newIdent) + " while dispatching to "
                    + msg.target.getClass().getName() + " "
                    + msg.callback + " what=" + msg.what);
        }
        // 回收消息，并把消息放入消息池
        msg.recycleUnchecked();
    }
}
可以看到 loop() 方法就是不停的遍历消息队列中的消息，当发现有新的消息时，便调用 Handler 的 dispatchMessage() 方法。## 6.4）getMainLooper()public static void prepareMainLooper() {
    prepare(false);
    synchronized (Looper.class) {
        if (sMainLooper != null) {
            throw new IllegalStateException("The main Looper has already been prepared.");
        }
        sMainLooper = myLooper();
    }
}
  /**
    * Returns the application's main looper, which lives in the main thread of the application.
    */
public static Looper getMainLooper() {
    synchronized (Looper.class) {
        return sMainLooper;
    }
}
getMainLooper() 方法用于返回当前 UI 线程的 Looper，UI 线程的 Looper 在 ActivityThread 的建立时通过调用 prepareMainLooper() 方法创建。## 6.5）quit() 和 quitSafely()在子线程中，如果手动为其创建了Looper，那么在所有消息处理完成之后应该调用 quit() 方法终止消息循环，不然 Looper 就会一直处于等待状态。public void quitSafely() {
    mQueue.quit(true);
}

public void quit() {
    mQueue.quit(false);
}
可以看到这两个方法都调用了 MessageQueue 中都 quit(boolean safe) 方法，quitSafely 的参数为 true，quit 的参数为 false。void quit(boolean safe) {
    // 主线程不退出消息循环
    if (!mQuitAllowed) {
        throw new IllegalStateException("Main thread not allowed to quit.");
    }
    synchronized (this) {
        // 如果已经退出了，直接 return
        if (mQuitting) {
            return;
        }

        // 标记为已经退出
        mQuitting = true;
        // 如果 safe 的值为 true，执行完当前的消息后退出消息循环
        if (safe) {
            removeAllFutureMessagesLocked();
        } else {
            // 直接退出消息循环
            removeAllMessagesLocked();
        }
        // We can assume mPtr != 0 because mQuitting was previously false.
        nativeWake(mPtr);
    }
}
quitSafely() 会等待当前消息执行完毕后退出消息循环，而 quit() 方法会直接退出消息循环。private void removeAllMessagesLocked() {
    // 获取当前 MessageQueue 的头部消息
    Message p = mMessages;
    while (p != null) {
        // 循环遍历所有的 Message
        Message n = p.next;
        // 回收消息，并把消息放入消息池
        p.recycleUnchecked();
        p = n;
    }
    // 将头部消息置为空
    mMessages = null;
}

private void removeAllFutureMessagesLocked() {
    // 获取系统从开机到现在到时间
    final long now = SystemClock.uptimeMillis();
    // 将当前的头部消息赋值给 p
    Message p = mMessages;
    if (p != null) {
        if (p.when > now) {
            // 如果当前头部消息将要执行的时间大于系统开机到现在的时间，则执行 removeAllMessagesLocked() 方法
            // 清空 MessageQueue 队列
            removeAllMessagesLocked();
        } else {
            Message n;
            // 遍历当前的 MessageQueue，直到某个消息的执行时间小于 now 值（即这个消息正在执行）
            // 将这个消息的 next 赋值为 null
            for (;;) {
                n = p.next;
                if (n == null) {
                    return;
                }
                if (n.when > now) {
                    break;
                }
                p = n;
            }
            p.next = null;
            // 回收不会被执行的 Message
            do {
                p = n;
                n = p.next;
                p.recycleUnchecked();
            } while (n != null);
        }
    }
}


1.2Handler导致的内存泄露原因及其解决方案
一、什么是内存泄露？
二、内存泄露的危害
三、解决方案
四、总结　
回到顶部
一、什么是内存泄露？

　　Java使用有向图机制，通过GC自动检查内存中的对象（什么时候检查由虚拟机决定），如果GC发现一个或一组对象为不可到达状态，则将该对象从内存中回收。也就是说，一个对象不被任何引用所指向，则该对象会在被GC发现的时候被回收；另外，如果一组对象中只包含互相的引用，而没有来自它们外部的引用（例如有两个对象A和B互相持有引用，但没有任何外部对象持有指向A或B的引用），这仍然属于不可到达，同样会被GC回收。

　　Android中使用Handler造成内存泄露的原因

复制代码
private Handler handler = new Handler()
 {
      public void handleMessage(android.os.Message msg)
　　　　 {
            if (msg.what == 1)
　　　　　　　　{
                noteBookAdapter.notifyDataSetChanged();
             }
        }
 };

复制代码
　　上面是一段简单的Handler的使用。当使用内部类（包括匿名类）来创建Handler的时候，Handler对象会隐式地持有一个外部类对象（通常是一个Activity）的引用（不然你怎么可能通过Handler来操作Activity中的View？）。而Handler通常会伴随着一个耗时的后台线程（例如从网络拉取图片）一起出现，这个后台线程在任务执行完毕（例如图片下载完毕）之后，通过消息机制通知Handler，然后Handler把图片更新到界面。然而，如果用户在网络请求过程中关闭了Activity，正常情况下，Activity不再被使用，它就有可能在GC检查时被回收掉，但由于这时线程尚未执行完，而该线程持有Handler的引用（不然它怎么发消息给Handler？），这个Handler又持有Activity的引用，就导致该Activity无法被回收（即内存泄露），直到网络请求结束（例如图片下载完毕）。另外，如果你执行了Handler的postDelayed()方法，该方法会将你的Handler装入一个Message，并把这条Message推到MessageQueue中，那么在你设定的delay到达之前，会有一条MessageQueue -> Message -> Handler -> Activity的链，导致你的Activity被持有引用而无法被回收。

回到顶部
二、内存泄露的危害

　　内存泄露的危害就是会使虚拟机占用内存过高，导致OOM（内存溢出），程序出错。

　　对于Android应用来说，就是你的用户打开一个Activity，使用完之后关闭它，内存泄露；又打开，又关闭，又泄露；几次之后，程序占用内存超过系统限制，FC。

回到顶部
三、解决方案

使用Handler导致内存泄露的解决方法

方法一：通过程序逻辑来进行保护。
1.在关闭Activity的时候停掉你的后台线程。线程停掉了，就相当于切断了Handler和外部连接的线，Activity自然会在合适的时候被回收。
2.如果你的Handler是被delay的Message持有了引用，那么使用相应的Handler的removeCallbacks()方法，把消息对象从消息队列移除就行了。

方法二：将Handler声明为静态类。
PS:在Java 中，非静态的内部类和匿名内部类都会隐式地持有其外部类的引用，静态的内部类不会持有外部类的引用。
静态类不持有外部类的对象，所以你的Activity可以随意被回收。由于Handler不再持有外部类对象的引用，导致程序不允许你在Handler中操作Activity中的对象了。所以你需要在Handler中增加一个对Activity的弱引用（WeakReference）。

代码如下：

复制代码
static class MyHandler extends Handler
    {
        WeakReference<Activity> mWeakReference;
        public MyHandler(Activity activity)
        {
            mWeakReference=new WeakReference<Activity>(activity);
        }
        @Override
        public void handleMessage(Message msg)
        {
            final Activity activity=mWeakReference.get();
            if(activity!=null)
            {
                if (msg.what == 1)
                {
                    noteBookAdapter.notifyDataSetChanged();
                }
            }
        }
    }
复制代码
　　PS：什么是WeakReference？
　　WeakReference弱引用，与强引用（即我们常说的引用）相对，它的特点是，GC在回收时会忽略掉弱引用，即就算有弱引用指向某对象，但只要该对象没有被强引用指向（实际上多数时候还要求没有软引用，但此处软引用的概念可以忽略），该对象就会在被GC检查到时回收掉。对于上面的代码，用户在关闭Activity之后，就算后台线程还没结束，但由于仅有一条来自Handler的弱引用指向Activity，所以GC仍然会在检查的时候把Activity回收掉。这样，内存泄露的问题就不会出现了。


1.3 一个线程可以有几个Handler,几个Looper,几个MessageQueue对象
之前我有篇文章里面写到了Android的消息机制，Handler发送消息的一些原理。链接如下：

从Handler.post(Runnable r)再一次梳理Android的消息机制（以及handler的内存泄露）

在消息机制里面，有一个非常重要的东西，那就是Looper，Looper的作用主要是从消息队列里面取出消息交给Handler处理，不过不仅限于此，在这里面还有很多东西值得我们去源码看一看：

1.从Looper.prepare()开始

要在一个线程里面处理消息，代码如下：

class LooperThread extends Thread
{
public Handler mHandler;
public void run()
{
Looper.prepare();
mHandler = new Handler()
{
public void handleMessage(Message msg)
{
// process incoming messages here
}
};
Looper.loop();
}
首先就必须要先调用Looper.prepare()，那这个方法做了些什么呢：

public static void prepare() {
        prepare(true);
    }

    private static void prepare(boolean quitAllowed) {
        if (sThreadLocal.get() != null) {
            throw new RuntimeException("Only one Looper may be created per thread");
        }
        sThreadLocal.set(new Looper(quitAllowed));
    }

代码其实只有关键性的一句，就是sThreadLocal.set(new Looper(quitAllowed))，首先来看看sThreadLocal

static final ThreadLocal<Looper> sThreadLocal = new ThreadLocal<Looper>();
ThreadLocal：代表了一个线程局部的变量，每条线程都只能看到自己的值，并不会意识到其它的线程中也存在该变量。

在这里ThreadLocal的作用是保证了每个线程都有各自的Looper

上面的判断也说明了一个问题：一个线程只能有一个Looper

接下来看看创建Looper实例的方法new Looper(quitAllowed)：

final MessageQueue mQueue;
final Thread mThread;

private Looper(boolean quitAllowed) {
        mQueue = new MessageQueue(quitAllowed);
        mThread = Thread.currentThread();
    }
在构造方法里，初始化了MessageQueue和代表当前线程的属性mThread，关于MessageQueue可以看看文章开头的链接，里面有详细的代码解析，这里就不赘述了。

调用Looper.prepare()其实就是利用ThreadLocal为当前的线程创建了一个独立的Looper，这其中包含了一个消息队列

2.创建Handler->new Handler()

在为当前线程创建了Looper之后，就可以创建Handler来处理消息了，这里可以解决我们一个疑问：

Handler是怎么跟Looper关联上的？

//全局变量
final Looper mLooper;
final MessageQueue mQueue;

public Handler(Callback callback, boolean async) {
        if (FIND_POTENTIAL_LEAKS) {
            final Class<? extends Handler> klass = getClass();
            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &&
                    (klass.getModifiers() & Modifier.STATIC) == 0) {
                Log.w(TAG, "The following Handler class should be static or leaks might occur: " +
                    klass.getCanonicalName());
            }
        }

        mLooper = Looper.myLooper();
        if (mLooper == null) {
            throw new RuntimeException(
                "Can't create handler inside thread that has not called Looper.prepare()");
        }
        mQueue = mLooper.mQueue;
        mCallback = callback;
        mAsynchronous = async;
    }
在Handler中有两个全局变量mLooper和mQueue代表当前Handler关联的Looper和消息队列，并在构造函数中进行了初始化，重要的就是调用了：Looper.myLooper()：

public static @Nullable Looper myLooper() {
        return sThreadLocal.get();
    }
其实还是调用的线程局部变量sThreadLocal，获取当前线程的Looper，这里需要注意的是，如果当前线程没有关联的Looper，这个方法会返回null。

注意：Handler在哪个线程创建的，就跟哪个线程的Looper关联，也可以在Handler的构造方法中传入指定的Looper

3.Looper.loop()循环读取消息

这个方法也在之前的文章里讲到过，核心就是一个死循环，从MessageQueue里面取消息出来交给Handler来处理。

线程消息机制的原理

看了源码之后，我们就知道了为啥在线程中需要处理消息，必须要经过以上三个步骤，且顺序不可更改

1.Looper.prepare()：为当前线程准备消息队列

2.Handler默认构造方法跟当前线程中的Looper产生关联

3.Looper.loop()开启循环取消息

衍生问题

一个线程可以有几个Looper？

这个问题在刚才已经探讨了，只能有一个，不然调用Looper.prepare()会抛出运行时异常，提示“Only one Looper may be created per thread”

一个线程可以有几个Handler

可以创建无数个Handler，但是他们使用的消息队列都是同一个，也就是同一个Looper

同一个Looper是怎么区分不同的Handler的，换句话说，不同的Handler是怎么做到处理自己发出的消息的

这个问题就要来到Handler的sendMessage方法里面了，具体的流程这里不详说了，最后来到了这个方法

Handler.enqueueMessage

private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
        msg.target = this;
        if (mAsynchronous) {
            msg.setAsynchronous(true);
        }
        return queue.enqueueMessage(msg, uptimeMillis);
    }
可以看到这一句msg.target = this;，这里就是将当前的Handler赋值给Message对象，这样在处理消息的时候通过msg.target就可以区分开不同的Handler了。处理的方法在Looper.loop中：

Looper.loop()

...
msg.target.dispatchMessage(msg);
...
顺便提一句，在Message的obtain的各种重载方法里面也有对target的赋值

1.2 Message对象创建的方式有哪些 & 区别？
 Message message = new message();
 Message message = Message.obtain();
 Message message = handler.obtainMessage();

1.3  Message.obtain()怎么维护消息池的
上一篇中共同探讨了ThreadLocal,这篇我们一起看下常提到的Message消息池到底是怎么回事，废话少说吧，进入正题。

对于稍有经验的开发人员来说我们在使用Handler发送异步消息获取Message的时候都会使用如下代码获取一个Message对象：

1 Message msg = mHandler.obtainMessage();
而不是直接new一个：

1 Message msg = new Message();
二者的主要区别就是上面的用到缓存池概念，如果池中有闲着的则拿来用，没有则new一个Message。后者则没有这个机制，直接new一个拿来用。

接下来我们分析一下这个缓存池是怎么实现的。

Message缓存池源码分析

Handler中obtainMessage()方法实质还是调用的Message中obtain()方法，这里就直接看Message中obtain()方法源码了：

复制代码
 1 public static Message obtain() {
 2         synchronized (sPoolSync) {
 3             if (sPool != null) {
 4                 Message m = sPool;
 5                 sPool = m.next;
 6                 m.next = null;
 7                 m.flags = 0; // clear in-use flag
 8                 sPoolSize--;
 9                 return m;
10             }
11         }
12         return new Message();
13  }
复制代码
第3行首先判断sPool是否为null，如果为null则直接执行12行直接new一个Message返回，整个方法结束，sPool是什么鬼？定义如下：

1 private static Message sPool;
看到了吧，就是一个Message对象，sPool其实就相当于一个头指针，指向缓存池中第一个缓存的Message,分析完所有就会自然明白了其作用。

继续向下分析。

sPool不为null则进入4-9行代码逻辑，sPool不为null说明缓存池中存在空闲的Message.

第4行记录sPool，并且第9行返回m作为整个方法的返回值，也就是返回缓存池中的空闲Message供外部使用，不需要额外内存开销。

第5行sPool指向下一个缓存对象。

第6行m.next置为null，到这里最重要的逻辑就完了，也许你还蒙蔽呢，这是什么啊，其实很简单Message的缓存池其实就是用了一个数据结构-单向链表。

接下来又要展示我强大的画图能力了，没有什么是一个图示不能解决的：



假设此时缓存池中有三个空闲message:message1,message2,message3。sPool一开始指向头部message1。

执行第4行代码相当于图中步骤①，没什么好解释的。

执行第5行代码相当于图中步骤②，sPool指向下一个缓存message,此处为message2.

执行第6行代码相当于图中步骤③，message1与message2断开连接。

怎么样这样解释该明白了，其实本身就很简单。

7,8行就是清除标记以及改变sPoolSize大小，sPoolSize用来记录缓存池中存在的元素个数，缓存池大小是有限制的，超过规定大小则不能再往里面添加。

obtain()总结

好了，到此主要逻辑就分析完了，obtain()主要逻辑就是先判断缓存池中是否存在空闲message，如果存在则返回头部message,并且指针指向下一个空闲message,然后头部的message与之后链表  断开连接。如果不存在空闲message则直接new一个直接返回。

上面的逻辑都是从缓存池中获取的操作，那什么时候向缓存池中存放呢？我们继续向下分析。

Message类中recycle()方法是用于回收用完的mesage，将此message会收到缓存池中，是这样的吗？我们看下源码就知道了：

复制代码
 1 public void recycle() {
 2         if (isInUse()) {
 3             if (gCheckRecycle) {
 4                 throw new IllegalStateException("This message cannot be recycled because it "
 5                         + "is still in use.");
 6             }
 7             return;
 8         }
 9         recycleUnchecked();
10 }
复制代码
recycle方法中主要判断当前message是否正在使用中，如果正在使用则抛出异常，没被使用则调用recycleUnchecked()方法，接下来看下recycleUnchecked()：

复制代码
 1 void recycleUnchecked() {
 2         // Mark the message as in use while it remains in the recycled object pool.
 3         // Clear out all other details.
 4         flags = FLAG_IN_USE;
 5         what = 0;
 6         arg1 = 0;
 7         arg2 = 0;
 8         obj = null;
 9         replyTo = null;
10         sendingUid = -1;
11         when = 0;
12         target = null;
13         callback = null;
14         data = null;
15
16         synchronized (sPoolSync) {
17             if (sPoolSize < MAX_POOL_SIZE) {
18                 next = sPool;
19                 sPool = this;
20                 sPoolSize++;
21             }
22         }
23 }
复制代码
4-14主要就是清除一些当前标记。

17行，MAX_POOL_SIZE就是规定的缓存池中最多缓存message的个数，如果当前已经存储的数量小于规定的最大缓存个数则继续向下执行。

18,19行就是重点了，又到展示我强大画图能力的时候了，一张图解决：



比如缓存池中链表中为message2,message3，sPool指向头部message2。

此时，message1被回收执行recycle()操作。最终执行到recycleUnchecked()的18,19行逻辑。

18行：相当于将图中message1的next指针指向sPool，此时sPool指向message2,也就是将message1与message2链接，也就是图中①操作。

19行：sPool重新定位到当前被回收的message,这里也就是message1。相当于图中②操作

recycle()总结

好了，到这里回收就讲完了，最主要就是18,19行逻辑，recycle()最主要就是将当前message放入缓存池链表头部。

到此，我想讲解的就完了，本篇核心就是数据结构中单项链表的实际应用，如果单向链表你很熟悉，我觉得这里应该很轻松的就理解了，即使不是很熟悉，用心思考一下也应该能理解，这里不难理解。

本篇就到此为止了，下一篇Android异步消息处理机制完全解析。

1.3 Handler 有哪些发送消息的方法
sendEmptyMessage()
sendMessage()
sendMessageAtFrontQueue()
sendMessageAtTime()
sendMessageDelayed()

1.4 Handler的post与sendMessage的区别和应用场景
sendMessage的用法：

public class MainActivity extends AppCompatActivity {
private TextView mTextView;
private String new_str = "";
//实例化Handler，重写回调方法
Handler mHandler = new Handler() {
    public void handleMessage(Message msg) {
        if (msg.what == 0) {
            /*sendMessage方法更新UI的操作必须在handler的handleMessage回调中完成*/
            mTextView.setText(new_str);
        }
    }
};
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    new Thread(new Runnable() {
        @Override
        public void run() {
            new_str = "sendMessage更新UI";
            /*sendMessage方法解决UI更新发送消息给handler（主线程中的handler）*/
            mHandler.sendEmptyMessage(0);
        }
    }).start();
}
post的用法：

public class MainActivity extends AppCompatActivity {
private TextView mTextView;
private String new_str = "";
//实例化Handler
private Handler mHandler = new Handler();
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    //这里调用了post方法，和sendMessage一样达到了更新UI的目的
     mHandler.post(new Runnable() {
            @Override
            public void run() {
                mTextView.setText(new_str);
            }
        });
    }
}).start();
}
上面的两种用法都是很常见的（这里未考虑内存泄漏，重点只关注Handler的使用），使用这两种方法都能够实现UI的更新，那么post和sendMessage有什么区别呢，我们要跟踪源码来看看post到底做了什么。

handler中post的源码：

public final boolean post(Runnable r)
{
   return  sendMessageDelayed(getPostMessage(r), 0);
}
//获得了message实例，将r赋给callback,接下来还是和sendMessage一致的操作，进入sendMessageDelayed
 private static Message getPostMessage(Runnable r) {
    Message m = Message.obtain();
    m.callback = r;
    return m;
}
public final boolean sendMessageDelayed(Message msg, long delayMillis)
{
    if (delayMillis < 0) {
        delayMillis = 0;
    }
    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);
}
最终还是到sendMessageAtTime这个方法里面

public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
    MessageQueue queue = mQueue;
    if (queue == null) {
        RuntimeException e = new RuntimeException(
                this + " sendMessageAtTime() called with no mQueue");
        Log.w("Looper", e.getMessage(), e);
        return false;
    }
    return enqueueMessage(queue, msg, uptimeMillis);
}
所以可以知道，handler.post和handler.sendMessage本质上是没有区别的，都是发送一个消息到消息队列中，只不过post使用方式更简单。
在handler的出队列方式中，可以看到如何进入不同的回调

消息出队列源码


 /**
 * Handle system messages here.
 */
   public void dispatchMessage(Message msg) {
  //如果是post,callback不为空，直接进入handleCallback
    if (msg.callback != null) {
        handleCallback(msg);
    } else {
   //如果是sendMessage,且创建handler时没有传入callback,则callback为空，直接进入handleMessage，也就是我们自己复写的处理Message的方法
        if (mCallback != null) {
            if (mCallback.handleMessage(msg)) {
                return;
            }
        }
        handleMessage(msg);
    }
}

//直接run并不会启动新线程，所以这就是post的runnable里面可以直接更新UI的原因
   private static void handleCallback(Message message) {
    message.callback.run();
}

1.5 handler postDelay后消息队列有什么变化，假设先 postDelay 10s, 再postDelay 1s, 怎么处理这2条消息
for (;;) {
    if (nextPollTimeoutMillis != 0) {
        Binder.flushPendingCommands();
    }

    nativePollOnce(ptr, nextPollTimeoutMillis);

    synchronized (this) {
        // Try to retrieve the next message.  Return if found.
        final long now = SystemClock.uptimeMillis();
        Message prevMsg = null;
        Message msg = mMessages;
        if (msg != null && msg.target == null) {
            // Stalled by a barrier.  Find the next asynchronous message in the queue.
            do {
                prevMsg = msg;
                msg = msg.next;
            } while (msg != null && !msg.isAsynchronous());
        }
        if (msg != null) {
            if (now < msg.when) {
                // Next message is not ready.  Set a timeout to wake up when it is ready.
                nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
            } else {
                // Got a message.
                mBlocked = false;
                if (prevMsg != null) {
                    prevMsg.next = msg.next;
                } else {
                    mMessages = msg.next;
                }
                msg.next = null;
                if (DEBUG) Log.v(TAG, "Returning message: " + msg);
                msg.markInUse();
                return msg;
            }
        } else {
            // No more messages.
            nextPollTimeoutMillis = -1;
        }
        ...
    }
 }
 1.6 MessageQueue是什么数据结构
在上一篇文章中我们分析了Handler 、Looper、 MessageQueue 、线程之间的关系，简单的说就是：一个线程绑定一个Looper，一个Looper维护一个MessageQueue队列，而一个线程可以对应多个Handler。而在Handler的消息机制中，MessageQueue可能算是最重要的，今天我们就来分析这个类。
在分析之前，先提出两个问题：
1.Handler.sendMessageDelayed()怎么实现延迟的？
2.Looper.loop是一个死循环，拿不到需要处理的Message就会阻塞，那在UI线程中为什么不会导致ANR？

现在，我们带着这两个问题进入MessageQueue的分析中。首先看第一个，Handler.sendMessageDelayed()的源码如下：

public final boolean sendMessageDelayed(Message msg, long delayMillis)
    {
        if (delayMillis < 0) {
            delayMillis = 0;
        }
        return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);
    }
可以看出 ： 消息被处理的时间 = 当前时间+延迟的时间

至于这个地方为什么要用SystemClock.uptimeMillis() 而不用SystemClock. currentTimeMillis()，这里可以看两者的区别（摘自网上）：

System.currentTimeMillis() 方法产生一个标准的自1970年1月1号0时0分0秒所差的毫秒数。该时间可以通过调用setCurrentTimeMillis(long)方法来手动设置，也可以通过网络来自动获取。这个方法得到的毫秒数为“1970年1月1号0时0分0秒 到 当前手机系统的时间”的差。因此如果在执行时间间隔的值期间用户更改了手机系统的时间，那么得到的结果是不可预料的。因此它不适合用在需要时间间隔的地方，如Thread.sleep, Object.wait等，因为它的值可能会被改变。

SystemClock.uptimeMillis()方法用来计算自开机启动到目前的毫秒数。如果系统进入了深度睡眠状态（CPU停止运行、显示器息屏、等待外部输入设备）该时钟会停止计时，但是该方法并不会受时钟刻度、时钟闲置时间亦或其它节能机制的影响。因此SystemClock.uptimeMillis()方法也成为了计算间隔的基本依据，比如Thread.sleep()、Object.wait()、System.nanoTime()以及Handler都是用SystemClock.uptimeMillis()方法。这个时钟是保证单调性,适用于计算不跨越设备的时间间隔。

Handler.sendMessageDelayed()方法最终会调用enqueueMessage方法进入MessageQueue的enqueueMessage方法中：

private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
        msg.target = this;
        if (mAsynchronous) {
            msg.setAsynchronous(true);
        }
        return queue.enqueueMessage(msg, uptimeMillis);
    }
MessageQueue中最重要的就是两个方法：
1.enqueueMessage向队列中插入消息
2.next 从队列中取出消息

先分析enqueueMessage：

boolean enqueueMessage(Message msg, long when) {
        if (msg.target == null) {//msg.target就是发送此消息的Handler
            throw new IllegalArgumentException("Message must have a target.");
        }
        if (msg.isInUse()) {//表示此消息正在被使用
            throw new IllegalStateException(msg + " This message is already in use.");
        }

        synchronized (this) {
            if (mQuitting) {//表示此消息队列已经被放弃了
                IllegalStateException e = new IllegalStateException(
                        msg.target + " sending message to a Handler on a dead thread");
                Log.w(TAG, e.getMessage(), e);
                msg.recycle();
                return false;
            }

            msg.markInUse();
            msg.when = when;//将延迟时间封装到msg内部
            Message p = mMessages;//消息队列的第一个元素
            boolean needWake;
            if (p == null || when == 0 || when < p.when) {
               //如果此队列中头部元素是null(空的队列，一般是第一次)，或者此消息不是延时的消息，则此消息需要被立即处理，此时会将这个消息作为新的头部元素，并将此消息的next指向旧的头部元素，然后判断如果Looper获取消息的线程如果是阻塞状态则唤醒它，让它立刻去拿消息处理

                msg.next = p;
                mMessages = msg;
                needWake = mBlocked;
            } else {
                //如果此消息是延时的消息，则将其添加到队列中，原理就是链表的添加新元素，按照when，也就是延迟的时间来插入的，延迟的时间越长，越靠后，这样就得到一条有序的延时消息链表，取出消息的时候，延迟时间越小的，就被先获取了。插入延时消息不需要唤醒Looper线程。

                needWake = mBlocked && p.target == null && msg.isAsynchronous();
                Message prev;
                for (;;) {
                    prev = p;
                    p = p.next;
                    if (p == null || when < p.when) {
                        break;
                    }
                    if (needWake && p.isAsynchronous()) {
                        needWake = false;
                    }
                }
                msg.next = p; // invariant: p == prev.next
                prev.next = msg;
            }

            // We can assume mPtr != 0 because mQuitting is false.
            if (needWake) {//唤醒线程
                nativeWake(mPtr);
            }
        }
        return true;
    }
源码中主要的地方我给了注释，可以参考参考。
由此可以看出：
MessageQueue中enqueueMessage方法的目的有两个：
1.插入消息到消息队列
2.唤醒Looper中等待的线程(如果是及时消息并且线程是阻塞状态)
同时我们知道了MessageQueue的底层数据结构是单向链表，MessageQueue中的成员变量mMessages指向的就是该链表的头部元素。

接下来我们再来分析一下取出消息的方法next()：

next()方法代码比较多，下面是主要部分，后面省略了一部分IdleHandler的处理逻辑，用于空闲的时候处理不紧急事件用的，有兴趣的自行分析。

Message next() {

        final long ptr = mPtr;
        if (ptr == 0) {
           //从注释可以看出，只有looper被放弃的时候（调用了quit方法）才返回null，mPtr是MessageQueue的一个long型成员变量，关联的是一个在C++层的MessageQueue，阻塞操作就是通过底层的这个MessageQueue来操作的；当队列被放弃的时候其变为0。
            return null;
        }

        int pendingIdleHandlerCount = -1; // -1 only during first iteration
        int nextPollTimeoutMillis = 0;
        for (;;) {
            if (nextPollTimeoutMillis != 0) {
                Binder.flushPendingCommands();
            }

            //阻塞方法，主要是通过native层的epoll监听文件描述符的写入事件来实现的。
           //如果nextPollTimeoutMillis=-1，一直阻塞不会超时。
           //如果nextPollTimeoutMillis=0，不会阻塞，立即返回。
           //如果nextPollTimeoutMillis>0，最长阻塞nextPollTimeoutMillis毫秒(超时)，如果期间有程序唤醒会立即返回。
            nativePollOnce(ptr, nextPollTimeoutMillis);

            synchronized (this) {

                final long now = SystemClock.uptimeMillis();
                Message prevMsg = null;
                Message msg = mMessages;
                if (msg != null && msg.target == null) {
                    //msg.target == null表示此消息为消息屏障（通过postSyncBarrier方法发送来的）
                    //如果发现了一个消息屏障，会循环找出第一个异步消息（如果有异步消息的话），所有同步消息都将忽略（平常发送的一般都是同步消息）
                    do {
                        prevMsg = msg;
                        msg = msg.next;
                    } while (msg != null && !msg.isAsynchronous());
                }
                if (msg != null) {
                    if (now < msg.when) {
                        // 如果消息此刻还没有到时间，设置一下阻塞时间nextPollTimeoutMillis，进入下次循环的时候会调用nativePollOnce(ptr, nextPollTimeoutMillis)进行阻塞；
                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                    } else {
                        //正常取出消息
                        //设置mBlocked = false代表目前没有阻塞
                        mBlocked = false;
                        if (prevMsg != null) {
                            prevMsg.next = msg.next;
                        } else {
                            mMessages = msg.next;
                        }
                        msg.next = null;
                        msg.markInUse();
                        return msg;
                    }
                } else {
                    //没有消息，会一直阻塞，直到被唤醒
                    nextPollTimeoutMillis = -1;
                }

                if (mQuitting) {
                    dispose();
                    return null;
                }

            pendingIdleHandlerCount = 0;
            nextPollTimeoutMillis = 0;
        }
    }


由此可以看出：
1.当首次进入或所有消息队列已经处理完成，由于此刻队列中没有消息（mMessages为null），这时nextPollTimeoutMillis = -1 ，然后会处理一些不紧急的任务（IdleHandler），之后线程会一直阻塞，直到被主动唤醒（插入消息后根据消息类型决定是否需要唤醒）。
2.读取列表中的消息，如果发现消息屏障，则跳过后面的同步消息。
3.如果拿到的消息还没有到时间，则重新赋值nextPollTimeoutMillis = 延时的时间，线程会阻塞，直到时间到后自动唤醒
4.如果消息是及时消息或延时消息的时间到了，则会返回此消息给looper处理。

通过enqueueMessage和next两个方法的分析我们不难得出：
消息的入列和出列是一个生产-消费者模式，Looper.loop()在一个线程中调用next()不断的取出消息，另外一个线程则通过enqueueMessage向队列中插入消息，所以在这两个方法中使用了synchronized (this) {}同步机制，其中this为MessageQueue对象，不管在哪个线程，这个对象都是同一个，因为Handler中的mQueue指向的是Looper中的mQueue，这样防止了多个线程对同一个队列的同时操作。

现在，我们对开篇的第一个问题做个回答：
Handler.sendMessageDelayed()怎么实现延迟的？
前面我们分析了如果拿到的消息还没有到时间，则会重新设置超时时间并赋值给nextPollTimeoutMillis，然后调用nativePollOnce(ptr, nextPollTimeoutMillis)进行阻塞，这是一个本地方法，会调用底层C++代码，C++代码最终会通过Linux的epoll监听文件描述符的写入事件来实现延迟的。

对于第二个问题：
Looper.loop是一个死循环，拿不到需要处理的Message就会阻塞，那在UI线程中为什么不会导致ANR？

首先我们来看造成ANR的原因：
1.当前的事件没有机会得到处理（即主线程正在处理前一个事件，没有及时的完成或者looper被某种原因阻塞住了）
2.当前的事件正在处理，但没有及时完成

我们再来看一下APP的入口ActivityThread的main方法：

public static void main(String[] args) {

        ...

        Looper.prepareMainLooper();

        ActivityThread thread = new ActivityThread();
        thread.attach(false);

        if (sMainThreadHandler == null) {
            sMainThreadHandler = thread.getHandler();
        }

        Looper.loop();

        throw new RuntimeException("Main thread loop unexpectedly exited");
    }

显而易见的，如果main方法中没有looper进行死循环，那么主线程一运行完毕就会退出，会导致直接崩溃，还玩什么！

现在我们知道了消息循环的必要性，那为什么这个死循环不会造成ANR异常呢？

我们知道Android 的是由事件驱动的，looper.loop() 不断地接收事件、处理事件，每一个点击触摸或者说Activity的生命周期都是运行在 Looper的控制之下，如果它停止了，应用也就停止了。只能是某一个消息或者说对消息的处理阻塞了 Looper.loop()，而不是 Looper.loop() 阻塞它，这也就是我们为什么不能在UI线程中处理耗时操作的原因。
主线程Looper从消息队列读取消息，当读完所有消息时，主线程阻塞。子线程往消息队列发送消息，唤醒主线程，主线程被唤醒只是为了读取消息，当消息读取完毕，再次睡眠。因此loop的循环并不会对CPU性能有过多的消耗。

1.7 Looper.quit/quitSafely的区别
Looper是通过调用loop方法驱动着消息循环的进行: 从MessageQueue中阻塞式地取出一个消息，然后让Handler处理该消息，周而复始，loop方法是个死循环方法。

那如何终止消息循环呢？我们可以调用Looper的quit方法或quitSafely方法，二者稍有不同。
Looper的quit方法源码如下：

public void quit() {
    mQueue.quit(false);
}
Looper的quitSafely方法源码如下：

public void quitSafely() {
    mQueue.quit(true);
}
以上两个方法中mQueue是MessageQueue类型的对象，二者都调用了MessageQueue中的quit方法，MessageQueue的quit方法源码如下:

void quit(boolean safe) {
        if (!mQuitAllowed) {
            throw new IllegalStateException("Main thread not allowed to quit.");
        }

        synchronized (this) {
            if (mQuitting) {
                return;
            }
            mQuitting = true;

            if (safe) {
                removeAllFutureMessagesLocked();
            } else {
                removeAllMessagesLocked();
            }

            // We can assume mPtr != 0 because mQuitting was previously false.
            nativeWake(mPtr);
        }
}
通过观察以上源码我们可以发现:
当我们调用Looper的quit方法时，实际上执行了MessageQueue中的removeAllMessagesLocked方法，该方法的作用是把MessageQueue消息池中所有的消息全部清空，无论是延迟消息（延迟消息是指通过sendMessageDelayed或通过postDelayed等方法发送的需要延迟执行的消息）还是非延迟消息。
当我们调用Looper的quitSafely方法时，实际上执行了MessageQueue中的removeAllFutureMessagesLocked方法，通过名字就可以看出，该方法只会清空MessageQueue消息池中所有的延迟消息，并将消息池中所有的非延迟消息派发出去让Handler去处理，quitSafely相比于quit方法安全之处在于清空消息之前会派发所有的非延迟消息。
无论是调用了quit方法还是quitSafely方法只会，Looper就不再接收新的消息。即在调用了Looper的quit或quitSafely方法之后，消息循环就终结了，这时候再通过Handler调用sendMessage或post等方法发送消息时均返回false，表示消息没有成功放入消息队列MessageQueue中，因为消息队列已经退出了。
需要注意的是Looper的quit方法从API Level 1就存在了，但是Looper的quitSafely方法从API Level 18才添加进来

1.8 通过Handler如何实现线程的切换

1.9 Handler 如何与 Looper 关联的
Looper
final MessageQueue mQueue;
//当前线程赋值 looper 对象，设置过之后，再次设置就会异常。

 private static void prepare(boolean quitAllowed) {
        if (sThreadLocal.get() != null) {
            throw new RuntimeException("Only one Looper may be created per thread");
        }

        .set(new Looper(quitAllowed));
    }
    //创建Looper 对象。MessageQueue对象赋值
    private Looper(boolean quitAllowed) {
        mQueue = new MessageQueue(quitAllowed);
        mThread = Thread.currentThread();
    }

    //获取当前线程的消息队列MessageQueue对象，死循环获取队列的Message 对象，
     public static void loop() {
        final Looper me = myLooper();
        if (me == null) {
            throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
        }
        final MessageQueue queue = me.mQueue;

        // Make sure the identity of this thread is that of the local process,
        // and keep track of what that identity token actually is.
        Binder.clearCallingIdentity();
        final long ident = Binder.clearCallingIdentity();

        for (;;) {
            Message msg = queue.next(); // might block
            if (msg == null) {
                // No message indicates that the message queue is quitting.
                return;
            }

            // This must be in a local variable, in case a UI event sets the logger
            final Printer logging = me.mLogging;
            if (logging != null) {
                logging.println(">>>>> Dispatching to " + msg.target + " " +
                        msg.callback + ": " + msg.what);
            }

            final long traceTag = me.mTraceTag;
            if (traceTag != 0) {
                Trace.traceBegin(traceTag, msg.target.getTraceName(msg));
            }
            try {
            //获取到Message 对象分发处理
            Handler 在将message加入到队列中时，给Message对象设置了target。
            msg.target = this; //this就是Handler对象
            所以 msg.target就是Handler，把该message加入到队列的handler，
                msg.target.dispatchMessage(msg);
            } finally {
                if (traceTag != 0) {
                    Trace.traceEnd(traceTag);
                }
            }

            if (logging != null) {
                logging.println("<<<<< Finished to " + msg.target + " " + msg.callback);
            }

            // Make sure that during the course of dispatching the
            // identity of the thread wasn't corrupted.
            final long newIdent = Binder.clearCallingIdentity();
            if (ident != newIdent) {
                Log.wtf(TAG, "Thread identity changed from 0x"
                        + Long.toHexString(ident) + " to 0x"
                        + Long.toHexString(newIdent) + " while dispatching to "
                        + msg.target.getClass().getName() + " "
                        + msg.callback + " what=" + msg.what);
            }

            msg.recycleUnchecked();
        }
    }

整个流程 就是handler把一个消息对象加到looper对象的 MessageQueue队列中，
每个线程的looper对象死循环自己的MessageQueue队列，然后handler dispatchMessage（msg）；

比如常见场景，子线程网络请求数据，主线程的handler对象发送 子线程封装好的Message对象。
在handler线程处理结果，常见场景更新UI。
这种场景message 加入的队列还是主线程Looper对象的MessageQueue。

   public Handler(Callback callback, boolean async) {
        if (FIND_POTENTIAL_LEAKS) {
            final Class<? extends Handler> klass = getClass();
            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &&
                    (klass.getModifiers() & Modifier.STATIC) == 0) {
                Log.w(TAG, "The following Handler class should be static or leaks might occur: " +
                    klass.getCanonicalName());
            }
        }

        mLooper = Looper.myLooper();
        if (mLooper == null) {
            throw new RuntimeException(
                "Can't create handler inside thread that has not called Looper.prepare()");
        }
        mQueue = mLooper.mQueue;
        mCallback = callback;
        mAsynchronous = async;
    }


    public Handler(Looper looper, Callback callback, boolean async) {
        mLooper = looper;
        mQueue = looper.mQueue;
        mCallback = callback;
        mAsynchronous = async;
    }
从Handler构造方法看，如果没有传入Looper 对象，默认Handler关联的是创建Handler对象的looper对象。
现在Android 系统只有主线程创建了Handler对象，所以在主线程使用Handler使用默认的主线程的looper对象，
如果在子线程创建handler，不去主动创建Looper对象。会出现异常。

 mLooper = Looper.myLooper();
        if (mLooper == null) {
            throw new RuntimeException(
                "Can't create handler inside thread that has not called Looper.prepare()");
        }

所以要想正常使用Handler，除了主线程，必须创建一个当前线程的looper对象。并且要调用Loop.loop();
或者是在子线程创建对象时，主动给Handler构造方法传入looper对象。这样handler关联的就是你主动加入的Looper对象。

1.8 MessageQueue的next()方法内部原理

