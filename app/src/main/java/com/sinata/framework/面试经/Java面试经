



1、java中==和equals和hashCode的区别
==是运算符，用来比较两个值、两个对象的内存地址是否相等
equals()
equals是Object类的方法，默认情况下比较两个对象是否是同一个对象，内部实现是通过“==”来实现的

hashCoed也是Object类里面的方法，返回值是一个对象的哈希码，同一个对象哈希码一定相等，但不同对象哈希码也有可能相等。

2、int、char、long各占多少字节数
byte             1个字节            最小值-128 (-2^7)    最大值127 2^7 - 1
boolean         至少一个1字节        这种类型只作为一种标记来记录true/false情况
short            2个字节            最小值是-2^15        最大值是2^15 - 1
char             2个字节            最小值是\n 0000      最大值是\uffff （65535）
int              4个字节            最小值是-2^31        最大值是2^31 - 1
float            4个字节            单精度浮点数字长32位，尾数长度23，指数长度8,指数偏移量127
long             8字节              最小值是 -2^63
double           8字节              双精度浮点数字长64位，尾数长度52，指数长度11，指数偏移量1023

3、int和Integer的区别
integer是int的包装类，int则是java的一种基本数据类型

4、Java中多态的理解
多态可以说是建立在继承的基础上的，所以我们先来理解一下继承。
 1.覆盖要求子类中的某一方法名和参数和父类中的某一方法名和参数完全一致。而重载只要求方法名一样而参数名必须不一致
 2.覆盖要求子类中的方法与父类中被覆盖的方法返回类型必须一致。而重载可以不一致（参数列表必须不一致）。
 3.覆盖要求子类覆盖父类的方法中不能有新抛出的异常类型。而重载允许有新抛出的异常类型。
 4.覆盖要求子类覆盖父类的方法的访问权限必须比父类的对应方法大（public > protected > default > private）。而重载则没有这种限制。



5、String、StringBuffer、StringBuilder区别
StringBuffer：线程安全，StringBuilder：线程不安全。因为 StringBuffer 的所有公开方法都是 synchronized 修饰的，而 StringBuilder 并没有 StringBuilder 修饰。

6、什么是内部类？内部类的作用
就是interface中只能定义方法，而不能有方法的实现，而在abstract class中则可以既有方法的具体实现，又有没有具体实现的抽象方法

7、抽象类和接口区别
就是interface中只能定义方法，而不能有方法的实现，而在abstract class中则可以既有方法的具体实现，又有没有具体实现的抽象方法

8、string 转换成 integer的方式及原理
首先我们需要了解，java虚拟机（jvm）采用了哪种垃圾回收机制去判断哪些对象该被回收，哪些不该被回收，我们通常采用以下两种方法：


9、哪些情况下的对象会被垃圾回收机制处理掉？

可用计数法
可达性分析法
那如何选择用哪种方法来进行垃圾回收？下面我们对这两个方法进行一下详细的分析：

1.1 可用计数法

这种方法是给对象增加一个计数器，每一次被引用时，计数器值+1；当引用失效时计数器-1。 当计数器为0的时候虚拟机就认为此对象时可以被回收的。看起来好像有点道理，但是这种方法存在一个致命的问题，就是无法检测“循环引用”：当两个对象互相引用，它俩的计数都不为零，因此永远不会被回收。而实际上对于开发者而言，这两个对象已经完全没有用处了。


若打X的线断了，但由于B、C、D之间存在引用，计数都不为0，他们永远不会被回收。因此，Java 里没有采用这样的方案来判定对象的“存活性。

1.2 可达性分析法

这个算法的基本思想是通过一系列成为GC Roots的对象作为起始点，从这些节点向下搜索，搜索所走过的路径成为引用链，当一个对象到GC Roots没有任何引用链（即该 GC Root不可达）时，则证明此对象是无用的，可以被回收。 在Java语言中，可以作为GCRoots的对象包括下面几种：

虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象）
方法区中的类静态属性引用的对象、常量引用的对象。
本地方法栈中JNI (Native 方法）引用的对象。


可见，对象是否会被垃圾收集与未被使用时间长短无关，仅仅在于这个对象是不是“活”的。

看完上面的分析，仔细思考一下java中单例对象会不会被GC回收？

答案是不会。因为java中单例模式创建的对象被自己类中的静态属性所引用，单例对象是方法区中的类静态属性引用的对象，引用链没有断，所以单例对象不会被jvm垃圾收集。

几种常见的编码格式





